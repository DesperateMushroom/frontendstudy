1. **带var和不带var的区别**
```
// 在全局作用域下的区别
/**

    不带var的：相当于给全局对象window设置了一个属性a
        window.a = 13;
*/
a = 13;


/*
    栈内存变量存储空间
        b
    带var的: 实在全局作用域下声明了一个变量b （全局变量）。但是在全局下声明的变量也
            同样相当于给window增加了一个对应的属性（只有全局作用域具备这个特点
*/
var b = 14; //=》 创建变量b & 给window设置了属性b
console.log(b);
console.log(window.b);





```



### 闭包作用域
1. 创建函数
    - 开辟一个堆内存
    - 把函数体中的代码当作字符串存储进去
    - 把堆内存的地址赋值给函数名/变量名
    - **函数在哪创建，那么它执行时候所需要查找的上级作用域就是谁**
2. 函数执行
    - 形成一个全新的私有作用域，执行上下文，私有栈内存（执行一次形成一个，多个之间也不会产生影响
    - 形参赋值 & 变量提升
    - 代码执行（把所属堆内存中的代码字符串拿出来一行行执行
    - **遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量就是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级作用域中查找，，， 一直找到全局作用域为止 -》 作用域链查找机制**
    - 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是 **闭包的保护机制**
3. 关于堆栈内存释放问题 （以谷歌webkit内核为例
> 函数执行就会形成栈内存（从内存中分配一块空间）。如果内存都不销毁 释放，很容易就会导致栈内存溢出，内存爆满，电脑就卡死了；堆栈内存的释放问题是学习js的核心知识之一
    - 堆内存释放问题
    ```
        //=> 创建一个引用类型值，就会产生一个堆内存
        // 如果当前创建的堆内存不被其他东西所占用了（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会被自己回收释放掉），则会释放

    let obj = { name:'aoao'};
    let oop = obj;
    // 此时obj和oop都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联
    // 指向null 空对象指针
    obj = null;
    oop = null;

    ```
    
    - 栈内存释放   
    ```
        //=> 打开浏览器形成的全局作用域就是栈内存
        //=> 手动执行函数形成的私有作用域是栈内存
        //=> 基于es6中的let/const 形成的块作用域也是栈内存
        //=> ...

        /*
            全局栈内存：关掉页面的时候才会销毁
            私有栈内存：
                1. 一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁掉（排除出现无限递归，死循环的模式
                2. 但是一旦栈内存中的某个东西（一般都是堆地址），被私有作用域以外的事物给占用了。则当前的栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也保留下来了 =》 市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的才是闭包
        */
        function fn(){....}
        fn();//-> 函数执行形成栈内存，执行完成栈内存销毁


        function X(){
            return function(){//...}
        }
        let f = X();//-> f占用了X执行的栈内存中第一个东西（返回小函数对应的对），则X执行形成的栈内存不能被释放了


        /*
            闭包两大作用
            1. 保护 （私有变量和外界没有必然联系
            2. 保存（形成不销毁的栈内存，里面的私有变量等信息保存下来
        */
    ```






#### let/const 和var 的区别
`1. let和const不存在变量提升机制`
> 创建变量的六种方式中：var/fucntion 有变量提升，而let/const/class/import都不存在这个机制 
`2. var允许重复声明，而let是不允许的`
> 在相同的作用域中（或执行上下文中），
- 如果使用var/function关键词声明变量并且重复声明，是不会有影响的
    （声明第一次之后，之后在遇到就不再重复声明了
- 但是使用let/const就不行，浏览器会校验当前作用域中是否已经存在这个变量了，
    如果已经存在，则再次基于let的声明会报错

`3. let能解决typeof检测时出现的暂时性死区问题 （let比var更严谨`



var a = 10, b = 20; 等价于 var a = 10; var b = 20;
var a=b=10; 等价于 var a = 10; b=10;  b不带var 