### 正则表达式
> regular expression: RegExp
> 用来处理字符串的规则
 - 只能处理字符串
 - 他是一个规则：可以验证字符串是否符合某个规则（test），
                也可以把字符串中符合规则的内容捕获到(exec / match)


```
let str = "good good study , day day up";

// 学正则就是用来制定规则的(是否包含连续的数字)
let reg = /\d+/;  

reg.test(str);


str = "2019-09-12";
// 用来捕获
reg.exec(str);  //['2019', index: 0, input: '2019-09-12']

```


#### 编写正则表达式
创建方式有两种
1. 字面量
2. 构造函数
```
// 字面量创建方法（两个斜杠//之间包起来的都是用来描述正则规则的元字符
let reg1 = /\d+/;


// 构造函数模式创建, 两个参数：元字符字符串，修饰符字符串
let reg2 = new RegExp("\\d+");



```
正则表达式由两部分组成
- 元字符
- 修饰符


/* 常用的元字符*/


// 1. 量词元字符：设置出现的次数

 - *     零到多次
 - +     一到多次
 - ？    零次或一次
 - {n}   出现n次
 - {n,}  出现n到多次
 - {n,m} 出现n到m次，包含n，m


// 2. 特殊元字符：单个或者组合在一起代表特殊的含义

 - \        转移字符（普通->特殊->普通）
 - .        除\n（换行符）以外的任意字符
 - ^        以哪一个元字符作为开始
 - $        以哪一个元字符作为结束 
 - \n       换行符
 - \d       0~9之间的一个数字
 - \D       非0-9之间的一个数字  （大写和小写的意思是相反的）
 - \w       数字、字母、下划线中的任意一个字符
 - \s       一个空白字符（包含空格、制表符、换页符等）
 - \t       一个制表符（一个TAB键：四个空格）
 - \b       匹配一个单词的边界
 - x|y      x或者y中的一个字符
 - [xyz]    x或者y或者z中的一个字符 
 - [^xy]    除了x/y以外的任意字符
 - [a-z]    指定a-z这个范围中的任意字符 [0-9a-zA-Z_] === \w
 - [^a-z]   上一个的取反“非”
 - ()       正则中的分组符号
 - (?:)     只匹配不捕获
 - (?=)     正向预查
 - (?!)     负向预查


// 3. 普通元字符: 代表本身含义的
/aoao/ 此正则匹配的就是 "aoao"





/* 正则表达式常用的修饰符：img */

i  =>  ignoreCase  忽略单词大小写匹配
m  =>  multiline   可以进行多行匹配
g  =>  global      全局匹配


```
// 这个字符串里包不包含大写字母A
/A/.test('lalala')  => false   
/A/i.test('lalala')  => true   i是忽略单词大小写

```



**元字符详细解析**
`^ $ `
```
let reg = /^\d/;
reg.test("aoao");   // F
reg.test("11aoao"); // T
reg.test("aoao11"); // F

```


```
let reg = /\d$/;
reg.test("aoao");   // F
reg.test("11aoao"); // F
reg.test("aoao11"); // T

```

```
let reg = /\d$/;
reg.test("aoao");   // F
reg.test("11aoao"); // F
reg.test("aoao11"); // T

```

```
// ^ / $ 两个都不加：字符串中包含符合规则的内容即可
let reg = /\d+/;
reg.test("aoao");   // F
reg.test("11aoao"); // T
reg.test("aoao11"); // T

// ^ / $ 两个都加：字符串只能是和规则一致的内容
let reg2 = /^\d+$/


// -> 举个例子：验证手机号码（11位，第一个数字是1即可）
let phone = /^1\d{10}$/
```




`\`  转义字符
```
// ->  这里的 . 不是小数点，是除了\n外的任意字符
let reg = /^2.3$/
reg.test("2.3"); // T
reg.test("2@3"); // T
reg.test("23");  // F  


// 基于转义字符，让其只能代表小数点
reg = /^2\.3$/
reg.test("2.3") // T
reg.test("2@3") // F


let str = "\\d";
reg = /^\d$/; // 不匹配str，因为\d代表的0-9的数字
reg.test(str); // false
reg = /^\\d$/; // 把特殊符号转换为普通的
reg.test(str); // true

```



`x|y`
```
let reg = /^18|29$/;
reg.test("18")      // T
reg.test("29")      // T
reg.test("129")     // T
reg.test("189")     // T
reg.test("1829")    // T
reg.test("829")     // T
reg.test("182")     // T

// ------- 直接x|y会存在很乱的优先级问题，
//          一般写的时候都伴随着小括号进行分组
//          因为小括号改变处理的优先级
reg = /^(18|29)$/     
reg.test("18")      // T
reg.test("29")      // T
reg.test("129")     // F
reg.test("189")     // F
reg.test("1829")    // F
reg.test("829")     // F
reg.test("182")     // F
// => 只能是18或者29中的一个了

```



`[]`
```
// 1. 中括号中出现的字符一般都代表本身的含义
let reg = /^[@+]$/;
console.log(reg.test("@@")); // F
console.log(reg.test("@+")); // F
console.log(reg.test("@")); // T
console.log(reg.test("+")); // T

let reg2 = /^[\d]$/;  //-> \d在中括号中还是0-9
console.log(reg2.test("\\")); // F
console.log(reg2.test("d")); // F
console.log(reg2.test("9")); // T




// 2. 中括号中不存在多位数
reg = /^[18]$/;
console.log(reg.test("1")); // T
console.log(reg.test("8")); // T
console.log(reg.test("18")); // F

reg = /^[10-29]$/;  // 1 or 0-2 or 9
console.log(reg.test("1")); // T
console.log(reg.test("9")); // T
console.log(reg.test("0")); // T
console.log(reg.test("2")); // T
console.log(reg.test("10")); // F


```



**常用的正则表达式**
1. 验证是否为有效数字
```
/*
 * 规则分析：
 *      1. 可能出现 + - 号，也可能不出现            [+-]
 *      2. 一位0-9都可以，多为首位不能是0           (\d|([1-9]\d+))
 *      3. 小数部分可能有可能没有，一旦有后面必须有小数点+数字  (\.\d+)?
 */


 let reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;

```

2. 验证密码
```
// 数字字母下划线
// 6-16位数
let val = userPassInput.value;
let reg = /^\w{6,16}$/
let flag = reg.test(val);

```

3. 验证真实姓名的
```
// 1. 汉字  /^[\u4E00-\u9FA5]$/
// 2. 名字长度 2~10位数
// 3. 可能有译名    ·汉字    (·[\u4E00-\u9FA5]{2,10}){0,2}

let reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10}){0,2}$/

```

4. 验证邮箱的
```
let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/

// ======》  \w+((-\w+)|(\.\w+))*
// 1. 开头是数字字母下划线（1到多位）
// 2. 还可以是 -数字字母下划线  或者   .数字字母下划线   整体0到多次
//      zhang-ao-ao
//      zhang.ao.ao
//      zhang-ao.ao
//      邮箱的名字由“数字，字母，下划线，-，.”及部分组成，但是 -/.不能连续出现也不能作为开头


// =====》  @[A-Za-z0-9]+
// 1. @后面紧跟着：数字，字母（1-多位）

// =====》  ((\.|-)[A-Za-z0-9]+)*
// 1. 对@后面名字的补充
// 多域名   .com.cn
// 企业邮箱 @aoao-cute.com


// =====》  \.[A-Za-z0-9]+
// 1. @xxx.com  /  @xxx.cn  这个匹配的是最后的域名
//       .com   .cn   .org   .edu   .net   .vip
```

5. 身份证号码
```
// 1. 18位数
// 2. 最后一位可能是X

// 身份证前六位：省市县
// 中间八位：年月日
// 最后四位：
//    最后一位：X | 数字
//    倒数第二位：女偶  男奇
//    其余的事经过算法算出来的

<!-- let reg = /^\d{17}*(\d|X)$/ -->

// =》 小括号分组的第二个作用: 分组捕获，
// 不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/

reg.exec("");
// 捕获结果是一个数组，包含每一个小分组单独获取的内容

```


**正则两种创建方式的区别**
```
let reg = /\\/;
console.log(reg.test("\\"));

// 构造函数中因为传递的是字符串， \需要写两个才能代表斜杠
let reg1 = /\d/g;
reg1 = new RegExp("\\d+","g");


// 正则表达式中的部分内容是变量存储的值
// 1. 两个斜杠中间包起来的都是元字符
//      如果正则中要包含某个变量的值，则不能用字面量方式创建
let type = "aoao";
reg = /^@"+type+"@$/
reg.test("@aoao@")  // F
reg.test('@"""typeee"@')  // T


// 2. 这种情况只能使用构造函数的方式（因为它传递的规则式字符串，只有这样
// 参能进行字符串拼接）
reg = new RegExp("^@"+type+"@$");
reg.test("@aoao@")  // T

```