<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3-js中的定时器动画</title>
    <link rel="stylesheet" href="../day25-2/css/reset.min.css">
    <style>
        .pic{
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            border: 1px solid lightcoral;

            /*设置过渡动画*/
           /* transition: 1s;*/
        }
    </style>
</head>
<body>
    
    <img src="../day25-2/images/2.jpg" alt="" class="pic">

    <!-- 定时器动画 -->
    <script>

        /*定时器动画：限定步长*/
/*         let pic = document.querySelector('.pic'),
            // target: 目标样式
            target = document.documentElement.clientWidth - pic.offsetWidth,
            //step: 步长
            step = 10;

        // 设置定时器，让其每间隔17ms向右走10
        // 改变left/transform：translateX
        let timer = setInterval(()=>{
            // 1. 获取当前盒子的位置
            // getComputedStyle
            // 在现有的位置上加上step
            let curL = window.getComputedStyle(pic).left;
            
            curL = parseFloat(curL);
            if((curL+step) >= target) {
                // 到达边界
                pic.style.left = target+'px';

                clearInterval(timer);
                timer = null;
                return;
            }
            curL += step;


            // 2. 重新给元素设置样式
            pic.style.left = curL + "px";
        },17); */
        
        /**
         * 定时器动画：限定时间的匀速运动
         *  T: time     当前运动的时间
         *  B: begin    开始位置
         *  D: duration 总时间
         *  C: change   总距离
         * 
         * 当前位置：T/D*C+B
         */ 

     /*     let pic = document.querySelector('.pic'),
            // target: 目标位置
            target = document.documentElement.clientWidth - pic.offsetWidth,
            // begin: 起始位置
            begin = parseFloat(window.getComputedStyle(pic).left),
            // change：总距离
            change = target - begin,
            // duration: 总时间
            duration = 1000,
            // time: 已经运动的时间
            time = 0;

            
        let timer = setInterval(()=>{
            time += 17;
            let curL = time / duration * change + begin;
            if(curL >= target){
                pic.style.left = target + 'px'; 
                clearInterval(timer);
                timer = null;
                return;
            }
            pic.style.left = curL + 'px';
        },17);

        function effect(t,b,c,d){
            if((t/=d /2)<1){
                return c/2*t*t*t+b;
            }
            return c/2*((t-=2)*t*t+2)+b;
        } */
   
        


   
   </script>


<!-- requestAnimationFrame -->
 <!--   <script>

    function effect(t,b,c,d){
        if((t/=d)<(1/2.75)){
            return c*(7.5625*t*t)+b;
        }
        else if(t<(2/2.75)){
            return c*(7.5625*(t-=(1.5/2.75))*t + 0.75)+b;
        }
        else if(t<(2.5/2.75)){
            return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375)+b;
        }
        else{
            return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375)+b;
        }
    }
    // window.requestAnimationFrame: js中比定时器动画更好的方式
    //                                html5中提供的

     let pic = document.querySelector('.pic'),
            target = document.documentElement.clientWidth - pic.offsetWidth,
            begin = parseFloat(window.getComputedStyle(pic).left),
            change = target - begin,
            duration = 2000,
            time = 0;

    
    function render(){
        time += 16.7;
        let curL = effect(time,begin,change,duration);
        if(curL >= target){
            pic.style.left = target + 'px'; 
            clearInterval(timer);
            timer = null;
            return;
        }
        pic.style.left = curL + 'px';
        window.requestAnimationFrame(render);
    }
    window.requestAnimationFrame(render);
   
   </script> -->


   <!-- css3动画 -->
   <!-- <script>
        // 用css3动画
        let pic = document.querySelector('.pic'),
            // target: 目标位置
            target = document.documentElement.clientWidth - pic.offsetWidth;
        
        pic.style.transform = `translateX(${target}px)`;
   </script> -->

  
   <!-- 多方向，规定时间，匀速动画 -->
   <!-- <script>
     let pic = document.querySelector('.pic'),
            // target: 目标位置
            targetL = document.documentElement.clientWidth - pic.offsetWidth,
            targetT = document.documentElement.clientHeight - pic.offsetHeight;

    /*
        animate: 封装一个建议的动画库
            @params: 
                ele: 当前要运动的元素
                target：目标样式值 对象{left: xxx, top:xxx}
                duration: 总时间
                callback：回调函数，动画完成后做什么事
    */
    function animate(ele, target={}, duration=1000, callback){
        // 准备 T B C D
        let time = 0,
            begin = {},
            change = {};

        // 初始化begin和change
        for(let key in target){
            begin[key] = parseFloat(window.getComputedStyle(ele)[key]);
            change[key] = target[key] - begin[key];
        }

        // 设置定时器开始运动
        let timer = setInterval(()=>{
            time = time + 16.7;
            // 边界判断
            if(time>=duration){
                for(let key in target){
                    ele['style'][key] = target[key] + 'px';
                }

                // 运动完执行回调函数
                // if(callback!==undefined) callback.call(this,...args);
                // callback && callback();
                typeof callback === 'function'?callback():null;
                clearInterval(timer);
                timer = null;
                return;
            }

            // 获取当前方向的样式值并且改样式
            for(let key in target){
                let cur = time / duration * change[key] + begin[key];
                // console.log(cur);
                ele['style'][key] = cur + 'px';
            }
        },16.7);
        
    }

    animate(pic, {
        left:targetL,
        top:targetT
    });

   /*  let time = 0,
        duration = 1000,
        beginT = 0,
        beginL = 0,
        changeT = targetT - beginT,
        changeL = targetL - beginL;
    

    let timer = setInterval(()=>{
        time = time + 16.7;

        if(time>=duration){
            pic.style.left = curL+'px';
            pic.style.top = curT+'px';
            clearInterval(timer);
            timer = null;
        }

        let curL = time / duration * changeL + beginL,
            curT = time / duration * changeT + beginT;
        
        pic.style.left = curL+'px';
        pic.style.top = curT+'px';
    },16.7);
 */
   </script> -->

<script src="../day22/node_modules/jquery/dist/jquery.min.js"></script>
   <!-- JQ -->
   <script>
    let $pic = $('.pic'),
        $window = $(window);
        targetL = $window.outerWidth() - $pic.outerWidth(),
        targetT = $window.outerHeight() - $pic.outerHeight();


    /**
     * animate: JQ中实现的动画库
     *     $元素.animate(目标样式，运动时间，运动方式，运动完执行的函数)
     * 
     * stop: 结束当前正在运行的动画，从现有的位置开始继续新的动画
     * 
     * finish: 也是结束当前正则运行的动画，和stop的区别是，
     *          finish时结束后快速运动到当前动画的结束位置
     *          再开始新的动画
     * 
     * 快捷动画：
     *  show/hide/toggle  显示/隐藏/显示隐藏的切换
     *  fadeIn/fadeOut/fadeToggle  渐隐渐现
     *  slideDown/slideUp/slideToggle  下拉和卷起
    */

     // 点击消失
     $pic.click(function(){
        // $pic.hide(200);  "slow"/"fast"/具体时间
        $pic.fadeOut(10);
     });

        // 结束状态，动画时长，动画轨迹，结束后的函数
/*     $pic.stop().animate({
        top:targetT,
        left:targetL
    },2000,'linear',()=>{
        // 结束之后的函数
        $pic.css('transform','rotate(180deg)');
    }); */
   </script>

</body>
</html>